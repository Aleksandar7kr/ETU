clc; clear; 

a = -2;  b = ;

x = a:0.01:b; 
y = x;


Y1 = f1(x,y);
Y2 = f2(x,y);

%Вывод обоих графиков на экран в 3d
plot3(x,y,Y1, x,y,Y2); grid;
%==================================

%или вывод линий уровня
%[X, Y] = meshgrid(x,y);

%hold on;

%Z = f(X, Y);
%contour(X, Y, Z, [0, 0]);

%Z = g(X, Y);
%contour(X, Y, Z, [0, 0]);

%grid;
%hold off;
%=================================
%можно кастовать вместе, красиво получается


%Метод Ньютона
x1 = [-1; -1];        %начальная точка поиска (вектор)
x2 = x1 + 1;

eps = 10^(-6);      %точность, дана по условию
out1 = []; i = 1;   %массив отклонений

while (norm(x2 - x1) > eps) %посольку x1 и x2 - вектора, то используем норму вектора, а не модуль разности
    x1 = x2;
    
    %матрица "поискового направления", состоящая из частных производных
    Y = [f1_dx(x1(1), x1(2)), f1_dy(x1(1), x1(2));
         f2_dx(x1(1), x1(2)), f2_dy(x1(1), x1(2))];
     
    %вектор значений функций в текущей точке х1
    tmp = [f1(x1(1), x1(2));  f2(x1(1), x1(2))];
        
    x2 = x1 - Y^(-1)*tmp;   %таким образом вычисляется новая точка х2
    
    out1(i) = x2(1) - x1(1);    %запоминаем сдвиг 
    
    i = i+1;
end
x2   
i    

%Метод Ньютона модифицированный
%отличается от предыдущего тем, что "поисковая" матрица создается один
%раз в начальной точке и далее не пересчитывается

x1 = [1; 1]; x2 = x1 + 1;
eps = 10^(-6);
Y = [f1_dx(x2(1), x2(2)), f1_dy(x2(1), x2(2)); f2_dx(x2(1), x2(2)), f2_dy(x2(1), x2(2))];
out2 = []; i = 1;

while (norm(x2 - x1) > eps)
    x1 = x2;
    
    tmp = [f1(x1(1), x1(2)) ;f2(x1(1), x1(2))];
       
    x2 = x1 - Y^(-1)*tmp;
    
    out2(i) = x2(1) - x1(1);    %запоминаем сдвиг 
    
    i = i+1;
end

x2   %вывод на экран минимума функции
i    %и количество итераций цикла, за которые мы нашли минимум

temp1  = max(size(out1))
temp2  = max(size(out2))

%Графики out1 и out2 
figure; plot(a:(b-a)/(temp1-1):b, out1, '*', a:(b-a)/(temp2-1):b, out2, 'r--'); grid; 